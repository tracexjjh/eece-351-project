import socket
import sys
import sqlite3
import bcrypt
import json
import threading

def get_db_connection():
    db = sqlite3.connect('AUBoutique.db', check_same_thread=False)
    cursor = db.cursor()
    return db, cursor

def create_tables():
    db, cursor = get_db_connection()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            username TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            address TEXT NOT NULL,
            password TEXT NOT NULL
        )
    """)
    db.commit()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS products (
            name TEXT PRIMARY KEY,
            picture BLOB,
            price REAL,
            description TEXT,
            owner TEXT NOT NULL,
            buyer TEXT,
            FOREIGN KEY (owner) REFERENCES users(username)
        )
    """)
    db.commit()

online_users = {}

def send_response(conn, response):
    conn.sendall(json.dumps(response).encode("utf-8"))

def register(conn, user_data):
    db, cursor = get_db_connection()
    username = user_data['username']
    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
    if cursor.fetchone():
        send_response(conn, {"message": "Username already exists."})
    else:
        password_hash = bcrypt.hashpw(user_data['password'].encode('utf-8'), bcrypt.gensalt())
        cursor.execute("INSERT INTO users (username, name, email, address, password) VALUES (?, ?, ?, ?, ?)",
                       (username, user_data['name'], user_data['email'], user_data['address'], password_hash))
        db.commit()
        send_response(conn, {"message": "Registration successful!"})

def login(conn):
    tries = 0
    db, cursor = get_db_connection()

    while tries < 3:
        message = conn.recv(1024).decode()
        if not message:
            break  # Exit if no message is received

        command_data = json.loads(message)  # Load the incoming JSON data
        username = command_data["username"]
        password = command_data["password"]

        cursor.execute("SELECT password FROM users WHERE username = ?", (username,))
        result = cursor.fetchone()

        if result and bcrypt.checkpw(password.encode('utf-8'), result[0]):
            print(f"User {username} logged in.")
            cursor.execute("SELECT name, description, price, owner FROM products")
            products = cursor.fetchall()
            product_list = [{"name": row[0], "description": row[1], "price": row[2], "owner": row[3]} for row in products]
            response = {
                "response": "Logged in successfully!",
                "products": product_list
            }
            send_response(conn, response)
            return username  # Return the username on successful login
        else:
            response = {"response": "Wrong Username Or Password"}
            send_response(conn, response)
            print("Wrong Username Or Password")
            tries += 1

    response = {"response": "You failed the login too many times. You are blocked."}
    send_response(conn, response)
    print("User blocked after too many failed attempts")
    conn.close()  # Close the connection

def view_products(conn, command_data):
    owner = command_data['owner']
    db, cursor = get_db_connection()
    cursor.execute("""
        SELECT name, price, description 
        FROM products 
        WHERE owner = ? AND buyer IS NULL
    """, (owner,))
    
    products = cursor.fetchall()  
    product_list = [{"name": product[0], "price": product[1], "description": product[2]} for product in products]
    response = {"response": "Products fetched successfully", "products": product_list}
    conn.sendall(json.dumps(response).encode("utf-8"))
    db.close()

def view_products_by_owner(conn, owner):
    db, cursor = get_db_connection()
    cursor.execute("""
        SELECT name, price, description 
        FROM products 
        WHERE owner = ? AND buyer IS NULL
    """, (owner,))
    
    products = cursor.fetchall()  
    product_list = [{"name": product[0], "price": product[1], "description": product[2]} for product in products]
    response = {"response": "Products fetched successfully", "products": product_list}
    send_response(conn, response)
    db.close()

def add_product(conn, product_data):
    db, cursor = get_db_connection()
    try:
        cursor.execute("""
            INSERT INTO products (name, description, price, owner, buyer) 
            VALUES (?, ?, ?, ?, NULL)
        """, (product_data['name'], product_data['description'], product_data['price'], product_data['owner']))
        db.commit()
        response = {"message": "Product added successfully!"}
    except sqlite3.IntegrityError:
        response = {"message": "Product already exists."}
    except Exception as e:
        response = {"message": f"An error occurred: {str(e)}"}
    finally:
        send_response(conn, response)
        db.close()

def buy_product(conn, username, product_name):
    db, cursor = get_db_connection()
    cursor.execute("SELECT * FROM products WHERE name = ? AND buyer IS NULL", (product_name,))
    product = cursor.fetchone()
    if product:
        cursor.execute("UPDATE products SET buyer = ? WHERE name = ?", (username, product_name))
        db.commit()
        send_response(conn, {"message": f"Product '{product_name}' bought successfully! Please collect your bought products from the AUB Post Office by next week!"})
    else:
        send_response(conn, {"message": "Product not available."})
    db.close()

def mark_product_as_bought(connection, product_id, buyer_username):
    cursor = connection.cursor()
    query = """
    UPDATE products 
    SET buyer = ? 
    WHERE name = ? AND buyer IS NULL
    """
    data = (buyer_username, product_id)
    
    try:
        cursor.execute(query, data)
        if cursor.rowcount == 0:
            response = "Error: Product not available or already bought."
        else:
            connection.commit()
            response = f"Success: Product '{product_id}' bought successfully!"
    except Exception as e:
        response = f"Error: Failed to mark product as bought. {str(e)}"
    
    return response  # Return plain text response

def initiate_chat(conn, command_data):
    owner = command_data["owner"]
    message = command_data["message"]

    if owner in online_users:
        owner_conn = online_users[owner]
        chat_message = {"from": command_data["username"], "message": message}
        owner_conn.sendall(json.dumps(chat_message).encode("utf-8"))
        response = {"response": "Message sent."}
    else:
        response = {"response": f"{owner} is not online."}
    
    send_response(conn, response)
    
def check_owner_status(conn, command_data):
    owner = command_data['owner']  # Get the owner from the command_data
    if owner in online_users:
        response = {"message": f"{owner} is online."}
    else:
        response = {"message": f"{owner} is offline."}
    
    conn.sendall(json.dumps(response).encode("utf-8"))
def receive_messages(conn):
    while True:
        try:
            message = conn.recv(1024).decode()
            if not message:
                break  # Exit if no message is received
            chat_message = json.loads(message)
            print(f"{chat_message['from']}: {chat_message['message']}")
        except:
            print("Connection lost.")
            break

def chat_with_owner(owner):
    print(f"Starting a chat with {owner}. Type 'exit' to end the chat.")
    
    # Start a thread to receive messages
    threading.Thread(target=receive_messages, args=(client_socket,), daemon=True).start()
    
    while True:
        message = input("You: ")
        if message.lower() == 'exit':
            break
        data = {
            "action": "chat",
            "owner": owner,
            "message": message
        }
        response = send_response(data)
        print(f"Response from {owner}: {response['response']}")

def handle_client(conn):
    username = None
    while True:
        message = conn.recv(1024).decode()
        if not message:
            break  # Exit if no message is received

        command_data = json.loads(message)  # Load the incoming JSON data
        action = command_data.get("action")

        if action == "register":
            register(conn, command_data)
        elif action == "login":
            username = login(conn)  # Assume login returns the username on success
            if username:
                online_users[username] = conn  # Add user to online users
        elif action == "check_online":
            check_owner_status(conn, command_data["owner"])
        elif action == "initiate_chat":
            initiate_chat(conn, command_data)
        elif action == "buy_product":
            buy_product(conn, username, command_data["product_name"])
        elif action == "view_products_by_owner":
            view_products_by_owner(conn, command_data["owner"])

    # Cleanup on client disconnect
    if username in online_users:
        del online_users[username]
        print(f"Connection closed for {username}.")
    conn.close()

if __name__ == "__main__":
    create_tables()
    if len(sys.argv) != 2:
        print("Usage: python server.py <port>")
        sys.exit(1)
    
    port = int(sys.argv[1])
    host = '127.0.0.1'
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((host, port))
    server.listen()
    print(f"Server listening on {host}:{port}")
    
    while True:
        client_socket, client_address = server.accept()
        print(f"Connection accepted from {client_address}")
        client_thread = threading.Thread(target=handle_client, args=(client_socket,))
        client_thread.start()
        
