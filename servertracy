import socket
import sys
import sqlite3
import bcrypt
import json
import threading
from datetime import datetime, timedelta

def get_db_connection():
    try:
        db = sqlite3.connect('AUBoutique.db', check_same_thread=False)
        cursor = db.cursor()
        return db, cursor
    except sqlite3.Error as error:
        print("Connection error with database:",error)
        return None,None

def create_tables():
    db, cursor = get_db_connection()
    if db is None or cursor is None:
        print ("Table creation failed due to database connection error")
        return 
    try:
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                username TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                password TEXT NOT NULL
            )
        """)
        db.commit()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS products (
                name TEXT PRIMARY KEY,
                picture BLOB,
                price REAL,
                description TEXT,
                owner TEXT NOT NULL,
                buyer TEXT,
                FOREIGN KEY (owner) REFERENCES users(username)
            )
        """)
        db.commit()
    except sqlite3.Error as error:
        print ("Error creating the table: ", error)
    finally:
        db.close()

online_users = {}
    
def send_response(conn, data):
    try:
        conn.sendall(data.encode("utf-8"))  
    except ConnectionError as e:
        print(f"Connection error occurred: {e}")
        return ""
    except Exception as e:
        print(f"An error occurred during request: {e}")
        return ""
    
def receive_request(received):
    received.recv(1024).decode("utf-8")

def register(conn):
    db, cursor = get_db_connection()
    data = receive_request(conn)
    data_dict = json.loads(data)

    name = data_dict["name"]
    email = data_dict["email"]
    username = data_dict["username"]
    password = data_dict["password"]
    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
    if cursor.fetchone():
        send_response(conn,"Username already exists.")
        return
    else:
        password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        cursor.execute("INSERT INTO users (username, name, email, password) VALUES (?, ?, ?, ?)",
                       (username, name, email, password_hash))
        db.commit()
        send_response(conn,"Registration successful!")
        
login_attempts_data = {}
maxattempts=3

def login(client_socket):
    db, cursor = get_db_connection()
    data = receive_request(client_socket)
    data_dict = json.loads(data)
    
    username = data_dict["username"]
    password = data_dict["password"]
    if username not in login_attempts_data:
        login_attempts_data[username] = {"attempts": 0, "lockout_time": None}

    user_data = login_attempts_data[username]
    current_time = datetime.now()
    if user_data["lockout_time"] and current_time < user_data["lockout_time"]:
        time_remaining = (user_data["lockout_time"] - current_time).seconds
        send_response(client_socket, f"Account locked. Try again in {time_remaining // 60} minutes.")
        return
    elif user_data["lockout_time"] and current_time >= user_data["lockout_time"]:
       
        user_data["attempts"] = 0
        user_data["lockout_time"] = None

    cursor.execute("SELECT password FROM users WHERE username = ?", (username,))
    result = cursor.fetchone()
    
    if result is None:
        send_response(client_socket, "Username does not exist.")
        return

    stored_password_hash = result[0]

    if bcrypt.checkpw(password.encode('utf-8'), stored_password_hash):
        user_data["attempts"] = 0
        user_data["lockout_time"] = None
        send_response(client_socket, "LOGIN SUCCESSFUL!")
    else:
        user_data["attempts"] += 1
        if user_data["attempts"] >= maxattempts:
            user_data["lockout_time"] = current_time + timedelta(minutes=3)
            send_response(client_socket, "Too many failed attempts. Account locked for 3 minutes.")
        else:
            send_response(client_socket, f"Incorrect password. {3 - user_data['attempts']} attempts remaining.")

def view_products(client):
    db, cursor = get_db_connection()
    cursor.execute("SELECT name, picture, price, description, owner FROM products WHERE buyer IS NULL")
    products = cursor.fetchall()
    
    product_list = [{"Product name": product[0], 
                     "Picture": product[1], 
                     "Price": product[2], 
                     "Description": product[3], 
                     "Owner": product[4]
                     } 
                    for product in products
                    ]
    response = json.dumps(product_list)
    send_response(client, response)  
    db.close()

def view_products_by_owner(conn, owner):
    db, cursor = get_db_connection()
    cursor.execute("""
        SELECT name, price, description, picture
        FROM products 
        WHERE owner = ? AND buyer IS NULL
    """, (owner,))
    
    products = cursor.fetchall()  
    product_list = [{"name": product[0], "price": product[1], "description": product[2], "picture": product[3]} for product in products]
    response = json.dumps({"response": "Products fetched successfully", "products": product_list})
    send_response(conn, response)  # Correctly send response
    db.close()

def add_product(conn, product_data):
    db, cursor = get_db_connection()
    if db is None or cursor is None:
        response = "Error: Unable to connect to the database"
        send_response(conn, response)
        return

    required_keys = ['name', 'description', 'price', 'picture', 'owner']
    if not all(key in product_data for key in required_keys):
        response = "Error: Missing product data fields"
        send_response(conn, response)
        return
    try:
        price = float(product_data['price'])

        cursor.execute("""
            INSERT INTO products (name, description, price, picture, owner, buyer) 
            VALUES (?, ?, ?, ?, ?, NULL)
        """, (product_data['name'], product_data['description'], price, product_data['picture'], product_data['owner'],))
        
        db.commit()
        response = "Product added successfully"
    except sqlite3.IntegrityError:
        response = "Error: Product already exists"
    except Exception as e:
        response = f"Error occurred: {str(e)}"
    finally:
        send_response(conn, response)
        db.close()

def buy_product(conn, username, product_name):
    db, cursor = get_db_connection()
    cursor.execute("SELECT * FROM products WHERE name = ? AND buyer IS NULL", (product_name,))
    product = cursor.fetchone()
    if product:
        cursor.execute("UPDATE products SET buyer = ? WHERE name = ?", (username, product_name))
        db.commit()
        send_response(conn,"Product bought successfully! Please collect your bought products from the AUB Post Office by next week!")
    else:
        send_response(conn,"Product not available.")
    db.close()

def view_buyers(conn, username):
    db, cursor = get_db_connection()
    cursor.execute("SELECT product_name, buyer FROM products WHERE owner = ?", (username,))
    buyerdetails = cursor.fetchall()
    buyers_list = [{"product_name": product[0], "buyer": product[1]} for product in buyerdetails]
    response = json.dumps({"response": "Buyers", "buyerdetails": buyers_list})
    send_response(conn, response)
    db.close()

def check_owner_status(conn, command_data):
    owner = command_data['owner']
    if owner in online_users:
        response = ("owner is online.")
    else:
        response = ("owner is offline.")
    send_response(conn, response)

def initiate_chat(conn, command_data):
    owner = command_data["owner"]
    message = command_data["message"]

    if owner in online_users:
        owner_conn = online_users[owner]
        chat_message = {"from": command_data["username"], "message": message}
        owner_conn.sendall(json.dumps(chat_message).encode("utf-8"))
        response = ("message sent.")
    else:
        response = ("owner is not online.")
    
    send_response(conn, response)

def receive_messages(conn):
    while True:
        try:
            message = conn.recv(1024).decode()
            if not message:
                break  # Exit if no message is received
            chat_message = json.loads(message)
            print(f"{chat_message['from']}: {chat_message['message']}")
        except Exception as e:
            print(f"Connection lost. Error: {e}")
            break  

def logout(connection, username, cursor, db):
     del online_users[username]
     print(f"Connection closed for {username}.")
     conn.close()
    
def handle_client(conn):
    while True:
        try:
            action = receive_request(conn)
            if not action:  
                print("User has disconnected unexpectedly.")
                return
    
            if action == "REGISTER":
                register(conn)  
            elif action == "LOGIN":
                login(conn)  
            elif action == "ADD_PRODUCT":
                add_product(conn, product_data)  
            elif action == "VIEW_PRODUCTS":
                view_products(conn)
            elif action == "VIEW_PRODUCTS_BY_OWNER":
                owner = conn.recv(1024).decode('utf-8')  
                view_products_by_owner(conn, owner) 
            elif action == "BUY_PRODUCT":
                username = conn.recv(1024).decode('utf-8') 
                product_name = conn.recv(1024).decode('utf-8') 
                buy_product(conn, username, product_name)  
            elif action == "VIEW_BUYERS":
                username = conn.recv(1024).decode('utf-8')  
                view_buyers(conn, username)  
            elif action == "CHECK_OWNER_STATUS":
                command_data = json.loads(conn.recv(1024).decode('utf-8'))  
                check_owner_status(conn, command_data)  
            elif action == "LOGOUT":
                username = conn.recv(1024).decode('utf-8')  
                logout(conn, username)  
            else:
                send_response(conn, "INVALID_COMMAND")
        except Exception as e:
            print(f"Error handling client request: {e}")

if __name__ == "__main__":
    create_tables()
    if len(sys.argv) != 2:
       print("Usage: python server.py <port>")
       sys.exit(1)
   
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('127.0.0.1', int(sys.argv[1])))
    server.listen(5)
    print("Server is listening...")
    
    while True:
        conn, addr = server.accept()
        print(f"Connection from {addr} accepted.")
        threading.Thread(target=handle_client, args=(conn,), daemon=True).start()

    server.close()
