import socket
import sys
import sqlite3
import bcrypt
import json
        db = sqlite3.connect('AUBoutique.db', check_same_thread=False)
        cursor = db.cursor()
        return db, cursor
    except sqlite3.Error as error:
        print("Connection error with database:", error)
        return None, None

# Create tables if they donâ€™t exist
def create_tables():
    db, cursor = get_db_connection()
    if db is None or cursor is None:
        print("Table creation failed due to database connection error")
        return
    try:
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                username TEXT PRIMARY KEY,
                password TEXT NOT NULL
            )
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS products (
                name TEXT,
                picture BLOB,
                price REAL,
                description TEXT,
                owner TEXT NOT NULL,
                buyer TEXT,
                FOREIGN KEY (buyer) REFERENCES users(username),
                FOREIGN KEY (owner) REFERENCES users(username)
            )
        """)
        db.commit()
    except sqlite3.Error as error:
        print("Error creating the table: ", error)
    finally:
        db.close()

# Send response to client
def send_response(conn, data):
    try:
        conn.sendall(json.dumps(data).encode("utf-8"))
    except ConnectionError as e:
        print(f"Connection error occurred: {e}")

# Receive request from client
def receive_request(conn):
    try:
        data = conn.recv(4096).decode("utf-8")  # Increased buffer size
        return json.loads(data)
    except json.JSONDecodeError:
        print("Failed to decode JSON from client.")
        return None

# Handle registration
def register(conn):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    data = receive_request(conn)
    if not data:
        return

    name, email, username, password = data.get("name"), data.get("email"), data.get("username"), data.get("password")

    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
    if cursor.fetchone():
        send_response(conn, {"status": "error", "message": "Username already exists."})
    else:
        password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        cursor.execute("INSERT INTO users (name,email,username,password) VALUES (?, ?, ?, ?)",
                       (name,email,username,password_hash))
        db.commit()
        send_response(conn, {"status": "success", "message": "Registration successful!"})
    db.close()

# Handle login with lockout mechanism
login_attempts_data = {}
MAX_ATTEMPTS = 3

def login(conn):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    data = receive_request(conn)
    if not data:
        return

    username, password = data.get("username"), data.get("password")
    user_data = login_attempts_data.get(username, {"attempts": 0, "lockout_time": None})

    # Lockout check
    current_time = datetime.now()
    if user_data["lockout_time"] and current_time < user_data["lockout_time"]:
        time_remaining = (user_data["lockout_time"] - current_time).seconds
        send_response(conn, {"status": "error", "message": f"Account locked. Try again in {time_remaining // 60} minutes."})
        return
    #needtohashpassword
    # Reset attempts if lockout period has passed
    if user_data["lockout_time"] and current_time >= user_data["lockout_time"]:
        user_data["attempts"] = 0
        user_data["lockout_time"] = None

    cursor.execute("SELECT password FROM users WHERE username = ?", (username,))
    result = cursor.fetchone()
    db.close()

    if result and bcrypt.checkpw(password.encode('utf-8'), result[0]):
        user_data["attempts"] = 0
        online_users[username]=conn
        send_response(conn, {"status": "success", "message": "Login successful!"})
    else:
        user_data["attempts"] += 1
        if user_data["attempts"] >= MAX_ATTEMPTS:
            user_data["lockout_time"] = current_time + timedelta(minutes=3)
            send_response(conn, {"status": "error", "message": "Too many failed attempts. Account locked for 3 minutes."})
        else:
            attempts_left = MAX_ATTEMPTS - user_data["attempts"]
            send_response(conn, {"status": "error", "message": f"Incorrect password. {attempts_left} attempts remaining."})

    login_attempts_data[username] = user_data

# View all products
def view_products(conn):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    cursor.execute("SELECT name, picture, price, description, owner FROM products WHERE buyer IS NULL")
    products = [{"name": row[0], "picture": row[1], "price": row[2], "description": row[3], "owner": row[4]} for row in cursor.fetchall()]
    send_response(conn, {"status": "success", "products": products})
    db.close()

# View products by owner
def view_products_by_owner(conn, owner):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    cursor.execute("SELECT name, picture, price, description FROM products WHERE owner = ? AND buyer IS NULL", (owner,))
    products = [{"name": row[0], "picture": row[1], "price": row[2], "description": row[3]} for row in cursor.fetchall()]
    send_response(conn, {"status": "success", "products": products})
    db.close()

# Add a product
def add_product(conn):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    data = receive_request(conn)
    if not data:
        return

    required_fields = ['name', 'picture', 'price', 'description', 'owner']
    if not all(field in data for field in required_fields):
        send_response(conn, {"status": "error", "message": "Missing product data fields"})
        return

    try:
        cursor.execute("INSERT INTO products (name, picture, price, description, owner) VALUES (?, ?, ?, ?, ?)",
                       (data['name'], data['picture'], float(data['price']), data['description'], data['owner']))
        db.commit()
        send_response(conn, {"status": "success", "message": "Product added successfully"})
    except sqlite3.IntegrityError:
        send_response(conn, {"status": "error", "message": "Product already exists for same user"})
    except Exception as e:
        send_response(conn, {"status": "error", "message": str(e)})
    finally:
        db.close()

# Buy a product
def buy_product(conn, username, product_name):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    cursor.execute("SELECT * FROM products WHERE name = ? AND buyer IS NULL", (product_name,))
    product = cursor.fetchone()
    if product:
        cursor.execute("UPDATE products SET buyer = ? WHERE name = ?", (username, product_name))
        db.commit()
        send_response(conn, {"status": "success", "message": "Product bought successfully! Collect it from the AUB Post Office next week!"})
    else:
        send_response(conn, {"status": "error", "message": "Product not available"})
    db.close()

# View buyers of products
def view_buyers(conn, username):
    db, cursor = get_db_connection()
    if db is None:
        send_response(conn, {"status": "error", "message": "Database connection failed"})
        return

    cursor.execute("SELECT name, buyer FROM products WHERE owner = ?", (username,))
    buyers = [{"product_name": row[0], "buyer": row[1]} for row in cursor.fetchall()]
    send_response(conn, {"status": "success", "buyers": buyers})
    db.close()

# Check owner status
online_users = {}

def check_owner_status(conn, owner):
    status = "online" if owner in online_users else "offline"
    send_response(conn, {"status": "success", "message": status})

# Track whether the owner is connected and their socket
owner_online = False
owner_socket = None
client_socket = None

# Define separate handlers for the owner and the client
def handle_owner_chat():
    global owner_online, owner_socket
    print("Owner connected.")
    owner_online = True
    owner_socket.send("You are now connected as the owner.".encode())

    while True:
        try:
            message = owner_socket.recv(1024).decode()
            if client_socket:
                client_socket.send(f"Owner: {message}".encode())
        except:
            print("Owner disconnected.")
            owner_online = False
            break
def initiatechat(conn):
    while True:
        data = receive_request(conn)
        if data.get("action") == "CHAT":
            target_user = data.get("to")
            if target_user in online_users:
                target_conn = online_users[target_user]
                target_conn.send(f"{data.get('from')}: {data.get('message')}".encode())
            else:
                send_response(conn, {"status": "error", "message": "User offline"})
    
def handle_client_chat(conn):
    global client_socket
    client_socket = conn

    if owner_online:
        conn.send("Owner is online. Starting chat...".encode())
    else:
        conn.send("Owner is offline. Try again later.".encode())
        conn.close()
        return

    while True:
        try:
            message = conn.recv(1024).decode()
            if message and owner_socket:
                owner_socket.send(f"Client: {message}".encode())
        except:
            print("Client disconnected.")
            client_socket = None
            break
        

# Main client handler
def handle_client(conn):
    while True:
        data = receive_request(conn)
        if not data:
            print("Client disconnected.")
            break

        action = data.get("action")
        
        if action == "REGISTER":
            register(conn)
        elif action == "LOGIN":
            login(conn)
        elif action == "VIEW_PRODUCTS":
            view_products(conn)
        elif action == "VIEW_PRODUCTS_BY_OWNER":
            view_products_by_owner(conn, data.get("owner"))
        elif action == "ADD_PRODUCT":
            add_product(conn)
        elif action == "BUY_PRODUCT":
            buy_product(conn, data.get("username"), data.get("product_name"))
        elif action == "VIEW_BUYERS":
            view_buyers(conn, data.get("username"))
        elif action == "CHECK_OWNER_STATUS":
            check_owner_status(conn, data.get("owner"))
        elif action == "CHAT_WITH_OWNER":
            role = data.get("role")  
            if role == "owner":
                handle_owner_chat()
            elif role == "client":
                handle_client_chat(conn)
        elif action == "LOGOUT":
            username = data.get("username")
            if username in online_users:
                del online_users[username]
                print(f"{username} has logged out.")
            send_response(conn, {"status": "success", "message": "Logged out successfully."})
        else:
            send_response(conn, {"status": "error", "message": "Invalid action"})
    conn.close()

# Server setup
def main():
    create_tables()
    if len(sys.argv) != 2:
        print("Usage: python server.py <port>")
        sys.exit(1)

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('127.0.0.1', int(sys.argv[1])))
    server.listen(5)
    print("Server is listening...")

    while True:
        conn, addr = server.accept()
        print(f"Connection from {addr} accepted.")
        threading.Thread(target=handle_client, args=(conn,), daemon=True).start()

    server.close()

if __name__ == "__main__":
    main()
